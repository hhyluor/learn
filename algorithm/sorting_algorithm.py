import random

li_1 = [3, 4, 2, 1, 5, 6, 8, 7, 9]


# 冒泡排序
def bubble_sort_1(li):
    for i in range(len(li) - 1):
        exchange = False  # 在第i趟那加标志位
        for j in range(len(li) - i - 1):
            if li[j] > li[j + 1]:
                li[j], li[j + 1] = li[j + 1], li[j]
                exchange = True  # 注：如果有交换 把它识成True  交换这里也是1个标志位
        if not exchange:  # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面)
            return  # 注：就直接结束掉这个函数


# 选择排序
def select_sort(li):
    # 还是需要n趟，每1趟出来1个最小的数
    # 但n-1趟放完后  还是1个数，那个数值最大的，所有和冒泡排序1样，需要n - 1趟
    for i in range(len(li) - 1):  # i 是第几趟
        # 遍历无序区的范围
        # 第0趟从0到最后，第1趟从1到最后，第i趟从i到最后
        min_loc = i  # 记最小值的位置(下标)，因为后面要做交换，记无序区的第1个数为最小值
        # for j in range(i,len(li)):  # i->列表长度 因为前包后不包所有写列表长度
        for j in range(i + 1, len(li)):  # 所以可以从 i + 1开始遍历
            # 没必要自己和自己比
            # j 是我们要从哪看到的
            if li[j] < li[min_loc]:  # 注：如果遍历的数 比那个数还要小
                min_loc = j  # 注：就min_loc继承j ；j就是最小值的下标
                # for循环执行完了 min_loc就是无序区最小的那个数的下标了
        li[i], li[min_loc] = li[min_loc], li[i]  # 最小的数和无序区的第1个值交换
        # 1趟就完成了 运行 n-1趟，选出n-1个数，最后1个数 一定是最大的
        print(li)


# 插入排序
# 时间复杂度：O(n2)
def insert_sort(li):
    for i in range(1, len(li)):  # 最开始手里已经有1张牌
        # i 表示摸到的牌的下标
        tmp = li[i]  # 注：把摸到的牌存起来 因为它要往后挪
        # 这个临时变量最后才用到，就是保存li[i]的 更形象
        j = i - 1  # 注：j 指的是手里的牌的下标 (起初是最右边的牌)
        # 如果j 这个牌 比 摸到的牌 小 就把摸到的牌插到j的右边
        # 如果j已经到最左边了 j=0的时候  比手里摸到的牌i
        # 如果j大  i小(摸到的牌) 则j往右挪一个
        while j >= 0 and tmp < li[j]:  # 循环里是 数往右移，j往前看下一个 ；tmp是li[i]
            # j >= 0 表示 j到了-1退出
            # 找到1个比只要j比摸到的牌i小的情况 退出
            li[j + 1] = li[j]  # 把数往右移了 (以前都理解错了，其实右边仅仅只是个值，左边被赋值)
            # 而且右边 一开始等于 j=i-1 j+1=i 的下标遍历不到的 不影响
            j = j - 1  # j 这个箭头往左移 1 个位置 ，右边仅仅是值 左边才是
        li[j + 1] = tmp  # while循环结束了 li[i]摸的牌写到 j+1的位置；代表插入i的 值 在j+1
        print(li)


# 快速排序-partition函数
def partition(li, left, right):
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp:  # 从右边找比tmp小的数
            right -= 1  # 往右走一步
        li[left] = li[right]  # 把右边的值写到左边空位上
        while left < right and li[left] <= tmp:
            left += 1
        li[right] = li[left]  # 把左边的值写到右边空位上
    li[left] = tmp  # 把tmp归位
    return left  # mid 是 这个函数返回left值的目的


# 快速排序-框架
def quick_sort(li, left, right):
    if left < right:  # 至少2个元素
        mid = partition(li, left, right)  # 这个函数返回left值的目的
        quick_sort(li, left, mid - 1)  # 左边部分
        quick_sort(li, mid + 1, right)  # 右边部分


# 堆排序
# 堆排序过程
# 1.建立堆。    # 注：农村包围城市，先县后省
# 2.得到堆顶元素，为最大元素    # 注：得到最大的元素后拿下来
# 3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。  # 注：找棋子上去，向下调整，重新有序
# 4.堆顶元素为第二大元素。
# 5.重复步骤3，直到堆变空。    # 注：接着重复拿出来放上去，直到堆空

def sift(li, low, high):  # 向下调整函数
    # li：列表
    # low: 堆的根节点位置
    # high: 堆的最后一个元素的位置
    i = low  # i最开始指向根节点
    j = 2 * i + 1  # j开始是左孩子
    tmp = li[low]  # 把堆顶存起来
    while j <= high:  # 只要j位置有数
        if j + 1 <= high and li[j + 1] > li[j]:  # 如果有孩子有并且比较大
            j = j + 1  # j指向右孩子
        if li[j] > tmp:
            li[i] = li[j]
            i = j  # 往下看一层
            j = 2 * i + 1
        else:  # tmp更大，把tmp放到i的位置上
            li[i] = tmp  # 该语句可省 # 把tmp放到某一级领导位置上
            break
    else:
        li[i] = tmp  # 把tmp放到叶子节点上


def heap_sort(li):  # 建堆函数
    n = len(li)
    for i in range((n - 2) // 2, -1, -1):
        # i表示建堆的时候调整的部分的根的下标
        sift(li, i, n - 1)  # 这里不是递归
    print(li)
    # 建堆完成了
    # ---------------------这一步 挨个出数的步骤
    for i in range(n - 1, -1, -1):
        # i指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0]
        sift(li, 0, i - 1)  # i-1是新的high


li2 = [i for i in range(100)]

random.shuffle(li2)  # 注：打乱
print(li2)

heap_sort(li2)
print(li2)


# topk实现

# 大多数排序在算法里叫做比较排序：通过比较2个值的大小 做操作(如交换)
# 注：如果是选前k大的数，那么我们要建立小根堆
# 注：之前写的sift函数是大根堆，要把它变成小根堆
def sift(li, low, high):  # 向下调整函数
    i = low
    j = 2 * i + 1
    tmp = li[low]
    while j <= high:
        if j + 1 <= high and li[j + 1] < li[j]:  # 注：li[j+1] > li[j] 改成<
            j = j + 1
        if li[j] < tmp:  # 注：li[j] > tmp 改成 <
            li[i] = li[j]
            i = j
            j = 2 * i + 1
        else:
            break
        li[i] = tmp


# 为什么这样改？
# li[j+1] < li[j] 这是取2个孩子里面更小的那一个
# li[j] < tmp   如果j小于拿下来的省长，就把它往上，否则就放回来
# 这样就满足 任何一个父亲 都比它的孩子小
# --------topk问题
def topk(li, k):
    heap = li[0:k]  # 注：把列表前k个取出来
    # 注：把heap部分取出来 进行建堆
    for i in range((k - 2) // 2, -1, -1):
        sift(heap, i, k - 1)
    # 1、建堆 ↑
    for i in range(k, len(li)):  # 看li下标是k开始的数 到最后，看他们和堆顶的关系
        if li[i] > heap[0]:  # 如果它 大于堆顶，说明堆顶不是前k大的数
            heap[0] = li[i]  # 那么把堆顶覆盖成li[i]
            sift(heap, 0, k - 1)  # 然后做1次调整
    # 2、遍历，遍历列表里剩下的所有的元素 ↑
    for i in range(k - 1, -1, -1):
        heap[0], heap[i] = heap[i], heap[0]
        sift(heap, 0, i - 1)
    # 3、出数 ↑
    return heap  # 因为存在了heap里 排好序的前k大的数 这样返回


li3 = list(range(1000))
random.shuffle(li3)  # 注：打乱
print(topk(li3, 10))


# 结果为 [999, 998, 997, 996, 995, 994, 993, 992, 991, 990]
# n特大的时候，不管k是多少，它肯定是最快的方法
# ------------------------------------------------------------------------


# 归并排序
def merge(li, low, mid, high):  # 注：后3个参数用来限定出 2段的位置
    # 注：li截出来的是 low 到 high这个位置。不从0开始 ，是为了后面的递归
    i = low  # 注：定义2个箭头下标（前1个箭头）
    j = mid + 1  # 注：定义2个箭头小标（后1个箭头）
    ltmp = []  # 注：临时列表，存放拿出来的值
    # 只有i、j都有数，比较一下，让小的那个数出来
    while i <= mid and j <= high:  # 只要左右2边都有数
        if li[i] < li[j]:  # 注：拿出2个箭头里 小的那个数
            ltmp.append(li[i])  # 注：存放小数 到临时列表
            i += 1  # 注：i的箭头往右移1个
        else:  # 注：j小的情况
            ltmp.append(li[j])
            j += 1
    # while执行完，2部分 肯定有1部分 没有数了。把2种可能都写下
    while i <= mid:  # 注：第1部分有数的情况
        ltmp.append(li[i])  # 注：把第1部分剩下的 都追加到 临时列表
        i += 1
    while j <= high:  # 注：如果右边有数
        ltmp.append(li[j])
        j += 1
    # 2个while只会有1个while执行。左边有数看i与mid；右边有数看j与high
    # 完了之后 ，ltmp里存好了排好序的东西，把临时的ltmp值 写回到li
    li[low:high + 1] = ltmp  # 切片往回写的语法


# 归并排序 —— 使用归并
# 分解：将列表越分越小，直至分成一个元素。
# 终止条件：一个元素是有序的。
# 合并：将两个有序列表归并，列表越来越大。
# 用到递归，终止条件：剩1个或0个, 就有序了
def merge_sort(li, low, high):  # low 第1个元素下标，high 最后1个元素下标
    if low < high:  # 至少有2个元素，递归    # 注：终止条件
        # 递归的来看，把归并排序看成只有3步
        # 1、归并排序左边
        # 2、归并排序右边
        # 3、把左边右边进行归并
        mid = (low + high) // 2  # 算mid  整除
        merge_sort(li, low, mid)  # 递归左边
        merge_sort(li, mid + 1, high)  # 递归右边
        # 左边右边都递归排序完了(左边右边 都有序了)，最后一步把2边归并
        merge(li, low, mid, high)


# 汉诺塔，3步。
# 第1步，把 n-1 个块移块来。不用管着 n-1里面什么情况，因为有递归终止条件，所以里面已经弄好了的
# 归并排序也是3步，1、把左边排好序；2、把右边拍好序；3、把左边和右边归并


# 希尔排序
# 希尔排序(Shell Sort)是一种分组插入排序算法。
# 首先取一个整数d1=n/2，将元素分为d1个组，每组相邻2个元素之间距离为d1，在各组内进行直接插入排序；
# 取第二个整数d2=d1/2，重复上述分组排序过程，直到 di=1，即所有元素在同一组内进行直接插入排序。
# 希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。
def insert_sort_gap(li, gap):  # 注：插入排序增加1个gap参数。gap参数:分的组
    # d=4时，2个元素之间的gap也是4
    # for i in range(1, len(li)):
    # 注：插入排序是从1到 n-1
    for i in range(gap, len(li)):
        # 注：从3开始，3的下标是gap 就是4 。所以从gap开始 到最后
        tmp = li[i]  # 手里的牌存起来
        # j = i - 1 # 原本的算法 是看摸到的牌的前1张牌，那是 手里的牌
        j = i - gap  # j指的是手里牌的下标,i是摸到的牌的下标 ，比如j = i - 4
        while j >= 0 and li[j] > tmp:
            # li[j + 1] = li[j]
            li[j + gap] = li[j]  # 注：意思是手里的牌 比摸到的牌大的时候，把手里的牌 往后移gap个（因为分组）
            # j = j - 1   # 注：以前是j往前看 ，看手里 前面那张牌
            j = j - gap  # 注：现在是看手里前面的牌，因为分组
        # li[j + 1] = tmp
        li[j + gap] = tmp  # 注：总结起来，就是把 1 都换成 gap


# 注：现在这个插入就是 d选定了之后，做这么1次 insert_sort_gap

def shell_sort(li):  # 注：希尔排序
    d = len(li) // 2  # 注：首先选定d 长度//2
    # 然后每次循环 做1次(li,gap) 传d 进来，然后d再除以2，直到d变成1的时候 就结束了
    while d >= 1:  # 注：满足条件  做循环
        insert_sort_gap(li, d)
        d //= 2  # 注：d整除2
        # 注：最后1次 ，d=2是 ，排序，d//2=1,d=1传入，做排序，d变成0.5 就退出了，满足情况
    # 注：所有while结束后，希尔排序就完成了


# 注：insert_sort_gap可以写在里面，但没必要，这样结构清晰些
# 注：希尔排序 至少不会比插入排序慢


# 计数排序
# 计数排序不是用比较排序，是用数一下
# 1 3 2 4 1 2 3 1 3 5
# 注：1-->往1位置上加1,3-->往3位置上加1…………
# 扫1遍
# 0   0
# 1   3     # 注：1+1+1
# 2   2     # 注：1+1
# 3   3     # 注：1+1+1
# 4   1     # 注：+1
# 5   1     # 注：+1
# 注：数了1下，这个列表里3个1,2个2,3个3,1个4,1个5
# 注：接下来 1 1 1 2 2 3 3 3 4 5
def count_sort(li, max_count=100):  # 注：max_count=100 默认最大的数为100
    # 除了需要li列表，还需要max_count 需要知道这个数最大是多少
    # 如果最大的值是100的话，需要101  0-100
    count = [0 for _ in range(max_count + 1)]  # 注：这是打印101个0   [0,0,0,0,……]
    # 遍历一下这个，往这个里面加数
    for val in li:
        count[val] += 1  # 注：这里val和下标对应。count的下标范围 0-100
        # 每遍历到1个数，就在cout对应的位置上+1
    # 这个for循环完了以后，所有的信息都在count里面
    li.clear()  # 把它都写在li里也行，把li清空
    # 接下来遍历 0 0      1 3     2 2     3 3     ……
    # 不光需要下标，还需要值。下标是这个数是几，值是这个数有几个
    for ind, val in enumerate(count):  # ind下标(数是几) ，val值(数有几个)
        # for循环里面就是说有val个ind，所有要把ind append val次
        for i in range(val):
            li.append(ind)  # 注：把ind  append  val次
        # 这个for循环以后，li就已经写回去了


def bucket_soet(li, n=100, max_num=10000):  # 注：li是列表，n是把它默认分成多少个桶(100个桶)，max_num 数的范围 是10000
    # 注：表示桶排序把这些元素分到100个桶里，知道这个数的最大值是10000
    # 注：不知道数的最大范围，但是 也是在某个场景下需要使用桶排序，也可以。可以规定1个最大数，比如说规定最大数是1亿，出来1个1亿零1怎么办？把它放到最后1个桶里面（不是新的桶，加到放到1亿的那个桶里）
    # n=100 桶号从0到99 即 0到n-1
    buckets = [[] for _ in range(n)]  # 注：列表生成式创建了1个二维列表，所有的一维的都是空的（桶是空的）
    # 注：创建n个桶
    # 注：需要创建好的桶buckets，buckets应该是1个桶的列表，桶本身又是1个列表，1个桶里可能存好多个数，所有相当于1个二维列表
    for var in li:  # 注：遍历列表里的所有数
        # 注：接下来绝定这个数var 放到哪个桶里。现在知道数的范围是0--10000
        # 0 --> 0(0放到0号桶里)，86 --> 0（86放到0号桶里）   # 注：0-99都放到0号桶里
        # 100 --> 199 都放到1号桶里
        # 0--10000的数，100个桶，1个桶里放 maxnum // n 个数，默人参数的时候 放100个数
        # i = var // (max_num // n)   #比如var=86，后面的max_num // n = 10000//100 是100，86 //100 是0 放到0号桶里
        # i表示var放到几号桶里
        # 186 //100 =1 放到1号桶里。9999放到99号桶里，10000 放到100号桶，但是没有100号桶，把10000放到99号桶里
        # 有1个问题 :当num=10000的时候，这个i是100 会放到100号桶里，会越界，怎么办？这样写 如下
        i = min(var // (max_num // n), n - 1)  # i表示var放到几号桶里
        # 注：桶号是从0到n-1 (n=100),桶号从0-99，也就是说最大的是99号桶
        # 注：它们两中取1个最小值，即使 max_num // n = 100,100跟99，只要大于99的，最后取出来全是99
        buckets[i].append(var)  # 注：把var放到i号桶，把它放过去了
        # 这个for循环结束后是 把var加到桶里面
        # 注:桶排序有不同的写法，我们可以就放过去就完事了，等这个for循环写完了，整个桶里元素该放的就放过去了，接下来对每个桶排序就可以了，这种写法简单一点，接下来写个for循环，对于每个桶再排序
        # 注：另外一种写法，放进去的过程中顺便就排序了，不是最后再排序。append一个元素，我就让它有序，那怎么让它有序呢？
        # [0,2,4,3] # 列表里已经让它有序了，如果它前面有元素，那前面一定是有序的。这个时候append一个3，接着只需要冒泡。只要前面1个数比3大，我就交换一下，前面的数比它小 就停掉
        # -------------------
        # 这个for循环结束之后，是保持桶内的顺序
        for j in range(len(buckets[i]) - 1, 0, -1):  # 注：j应该从最后1个元素开始（buckets[i]这个桶的最后1个元素）
            # 注：到第2个元素停，因为是跟它前面一个元素比。冒泡排序 for j 也是这样，因为它要跟2个比，所以得空出来1个，不是是从0到n-1
            # for j 要么从 1到n-1，遍历后边的 拿它和前面的元素比；要么从0到n-2,拿它跟后边元素比
            # 所以如果是从n-1开始，那么是到1号位置为止。到1号位置 写0 ，因为后不包，写0 最多j取到1
            if buckets[i][j] < buckets[i][j - 1]:  # 注：也就是说这个元素 小于它前面那个元素 ，那我就交换它     # 注：前面那个元素下标为j-1
                # 如果后面的数比前面的数小,交换位置
                buckets[i][j], buckets[i][j - 1] = buckets[i][j - 1], buckets[i][j]
            # [0,2,4,1]  # 注：j的位置是1，拿j跟j-1这个位置比。1跟4交换 [0,2,1,4]
            # [0,1,2,4] 注：1跟2交换
            else:  # 如果后面的数比前面的数大。比如1已经是插在正确位置上的，就直接break，不用继续了，即使前面再有-2，-1，都和它没关系了
                break
        # 这个for循环结束之后，是保持桶内的顺序
    # 等外面的for循环完了以后，就是 所有的元素都被放到桶里，而且桶里是有序的。到这个位置，桶就已经维持好了
    # 接下来把桶里的数挨个输出出来就可以了
    sorted_li = []  # 注：建立空列表，准备接收桶里的那些数据
    for buc in buckets:  # 注：遍历一下这个桶，buc 是一维列表，是每一个桶
        sorted_li.extend(buc)  # 注：就把这个一维列表buc加到sorted_li列表的后面
    return sorted_li  # 注：返回排序好了的列表


# 基数排序
def radix_sort(li):
    # 基数排序 十位的话做2次，个位先进桶，十位进桶；百位做3次；相当于几次是一个几次的循环
    # 注：循环的次数怎么确定？根据最大值确定
    max_num = max(li)  # 注：确定最大值。如果最大值是99 ，做2次。
    # 注：最大值 9-->1次，99-->2次, 888-->3次, 10000-->5次
    # 注：最大数的位数是几，就做几次循环
    # 注：怎么确定最大值的位数？2种方法。
    # 1、通过log函数，取以十为底的对数。lg1000=4，lg888的对数是3点几，向下取整 就可以了
    # 不知道也没关系
    it = 0  # 注：it 是迭代多少次 iteration # it是第几次分桶。第1次是个位，第2次是十位
    while 10 ** it <= max_num:
        # 注：如果最大值是9，进来的话，刚开始是10的0次方=1,1<=9，执行一次，分桶 分桶完毕再出来
        # 注：然后it+=1,10**1=10，10大于9，跳出了
        # 注：888也是一样，刚开始10**0<=888，1次；接下来10**1=10 <= 888,2次；10**2=100 <= 888,3次；10**3 > 888，这才大于
        # 注：所有888做了3次
        # 注：如果是10000，it=4的时候，是小于等于，它还是执行，等于4的时候是第5次，也没有问题
        buckets = [[] for _ in range(10)]  # 注：分10个桶，桶的个数是一定的 0-9
        # 注：接下来是分桶，跟介绍桶排序的概念是一样的
        for var in li:
            # 注：对于每一个元素，把它放到桶里去
            # 注：怎么确定它分到几号桶？ 取决于当前看的它哪一位数
            # 注：it=0时，看的是个位，it=1 看的十位，it=2 看的百位
            # 例子：987 it=1，取8出来。it=2  取第3位9  987//100->9 9%10=9
            # it=0取7，it=1取8，it=2取9
            # 怎么取第2位：987//10 -->98，98%10 -->8。先整除10，再模10
            # 注：1个数，取个位数 987%10，模10就可以了（取余运算）
            # 注：取第2位，百位  987//10 -->98  98%10 -->8
            # 注：取第3位，千位  987//100 -->9  9%10-->9
            dight = (var // 10 ** it) % 10  # 注：分到几号桶和it的关系是这个
            buckets[dight].append(var)  # 注：找到var对应的桶，追加
        # 这个for循环完了后，分桶完成。接着是把元素再取出来 放回到li里
        li.clear()  # 注：先清空 再放回
        for buc in buckets:
            li.extend(buc)
        # 注：这个for循环是 把数重新写回li
        it += 1  # 注：it += 1是又重新建桶，然后按下一个分桶，最后再写入li
    # 注：这些结束后 li就已经是有序的了
